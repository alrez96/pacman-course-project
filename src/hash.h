/* * 	Name:	SDL Wrapper * 	Author:	Hash Team * 	Description:	A c++ wrapper to hide Object Oriented nature of SDL *///	Header files have different path in linux and windows#if defined(_WIN32) || defined(_WIN64)	//	If Windows	#include "SDL.h"	#include "SDL_image.h"	#include "SDL_ttf.h"	#include "SDL_mixer.h"#elif defined(__linux__)	//	If linux (Ubuntu tested successfully)	#include "SDL/SDL.h"	#include "SDL/SDL_image.h"	#include "SDL/SDL_ttf.h"	#include "SDL/SDL_mixer.h"#endif//	Define colors for SDL_FillRect function#define  WHITE  0xFFFFFF#define  RED    0xFF0000#define  BLACK  0x000000#define  BLUE   0x0000FF    #define  GREEN  0x00FF00#define  PINK   0xFF00FF#define  PURPLE 0x400080#define  YELLOW 0xFFFF00#define  LIGHT_PURPLE  0x8000FFSDL_Event event;int ExitRequested=0;static void Input();static bool GetKey(SDLKey key);static bool GetKeyDown(SDLKey key);static bool GetKeyUp(SDLKey key);static bool curKey[322];static bool preKey[322];void Input(){memset(curKey,0,sizeof(bool)*322);memset(preKey,0,sizeof(bool)*322);}struct mouse {        int left ;         int right;        int x ;         int y ;         int middle;        int wheelUp ;         int wheelDown;}Mouse;#define MouseX	Mouse.x#define MouseY	Mouse.y#define MouseLB	Mouse.left#define MouseRB	Mouse.rightinline void InitEngine(SDL_Surface * & screen,char* WindowsTitle, unsigned int WindowsHeight ,unsigned int WindowsWidth ){       atexit(SDL_Quit);       if( SDL_Init(SDL_INIT_VIDEO) < 0 ) exit(1);       SDL_WM_SetCaption(WindowsTitle,NULL);       screen = SDL_SetVideoMode( WindowsHeight, WindowsWidth , 32 , SDL_DOUBLEBUF|SDL_HWSURFACE|SDL_ANYFORMAT);              ExitRequested=0;              // Inilialize SDL_mixer , exit if fail       if( SDL_Init(SDL_INIT_AUDIO) < 0 ) exit(1);       // Setup audio mode       Mix_OpenAudio(22050,AUDIO_S16SYS,2,640);              TTF_Init();}inline void InitEngine(SDL_Surface  * & screen,char* WindowsTitle){       InitEngine(screen , WindowsTitle , 850,600);}inline void InitEngine(SDL_Surface * & screen){		char name[50]="Pacman Game";       InitEngine(screen,name);}void Update (){ 	memcpy(preKey,curKey,sizeof(bool)*322);     while(SDL_PollEvent( &event ))     switch (event.type)     {	case SDL_KEYDOWN:	{		curKey[event.key.keysym.sym] = true;		break;	}	case SDL_KEYUP:	{		curKey[event.key.keysym.sym] = false;		break;		}            case SDL_MOUSEBUTTONDOWN:                 switch (event.button.button)                 {                 case 1:                      Mouse.left=1;                      break;                 case 2:                      Mouse.middle=1;                      break;                case 3:                       Mouse.right=1;                      break;               case 4:                      Mouse.wheelUp=1;                      break;                case 5:                       Mouse.wheelDown=1;                      break;                                                             }                 break;                                case SDL_MOUSEBUTTONUP:                 switch (event.button.button)                 {                 case 1:                      Mouse.left=0;                      break;                 case 2:                      Mouse.middle=0;                      break;                case 3:                       Mouse.right=0;                      break;               case 4:                      Mouse.wheelUp=0;                      break;                case 5:                       Mouse.wheelDown=0;                      break;                                                            }                 break;            case SDL_MOUSEMOTION:                 Mouse.x=event.motion.x;                 Mouse.y=event.motion.y;                 break;             case SDL_QUIT:                ExitRequested = 1;                break;         }}inline void ShowCursor(){       SDL_ShowCursor(1);}inline void HideCursor(){       SDL_ShowCursor(0);}//+++++++++++++++++++++++bool GetKey(SDLKey key){return curKey[key];}bool GetKeyDown(SDLKey key){return curKey[key] && !preKey[key];}bool GetKeyUp(SDLKey key){return !curKey[key] && preKey[key];}//+++++++++++++++++++++++++++++inline SDL_Surface *ImgLoader(char *file,bool bCKey, int r , int g , int b , int alpha){    SDL_Surface *pic;    pic = IMG_Load(file); // From SDL_image.h , load the image to pic    // Log error message into stderr.txt if happened    if(pic==NULL) fprintf(stderr,"Missing image %s : %s\n",file,IMG_GetError());    if( bCKey ) {        // Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.       SDL_SetColorKey(pic,SDL_SRCCOLORKEY|SDL_RLEACCEL,SDL_MapRGB(pic->format,r,g,b));         }    if(alpha) SDL_SetAlpha(pic, SDL_SRCALPHA|SDL_RLEACCEL , 255 - alpha);    // This function takes a surface and copies it to a new surface of the     // pixel format and colors of the video framebuffer, suitable for fast     // blitting onto the display surface.    pic = SDL_DisplayFormat(pic);    return (pic);}inline SDL_Surface *ImgLoader(char *file, int r , int g , int b ){       return ImgLoader(file,1,r,g,b,0);}inline SDL_Surface* ImgLoader(char* file,int r,int g,int b,int alpha){       return ImgLoader(file,1,r,g,b,alpha);}// Load a normal picture into a surfaceinline SDL_Surface *ImgLoader(char *file)                       { return ImgLoader(file,0,0,0,0,0) ; }                // **********************************//              Audio Functions#define Sound Mix_Chunk#define Music Mix_Musicinline void PlaySound(Sound* sound){       Mix_PlayChannel(-1,sound,0);}inline void PlaySound(Sound* sound,int Count){       if (Count!=0)          Mix_PlayChannel(-1,sound,(Count>0)?Count-1:-1);}inline void PlayMusic(Music* music){       Mix_PlayMusic(music,1);}inline void PlayMusic(Music* music,int Count){       Mix_PlayMusic(music,Count);}inline Sound* LoadSound(char* path){       Mix_LoadWAV(path);}inline Music* LoadMusic(char* path){       Mix_LoadMUS(path);}inline void StopMusic(){       Mix_HaltMusic();}inline void StopAllSounds(){        Mix_HaltChannel(-1);}            inline void Free(Sound* sound){       Mix_FreeChunk(sound);}inline void Free(Music* music){    Mix_FreeMusic(music);}//	Overload of 'SDL_BlitSurface' accept cordination without structinline int SDL_BlitSurface(SDL_Surface *src, SDL_Surface *dst, int x,int y){	SDL_Rect tempRect;	tempRect.x=x;	tempRect.y=y;	return SDL_BlitSurface(src,NULL,dst,&tempRect);}inline SDL_Surface* TTF_RenderText_Solid(TTF_Font *font,const char *text,Uint8 r,Uint8 g,Uint8 b){	SDL_Color c;	c.r=r;	c.g=g;	c.b=b;	return TTF_RenderText_Solid(font,text,c);}